import time
import subprocess
import platform
import psutil
from email.mime.multipart import MIMEMultipart
import smtplib
from email.mime.text import MIMEText
import datetime

# Path to the log file generated by the monitor.py script
LOG_FILE_PATH = "event_log.txt"
ALERT_COOLDOWN_PERIOD = 300 
last_alert_time = None

SMTP_SERVER = "smtp.gmail.com"
SMTP_PORT = 587
SMTP_USERNAME = "untsegroup@gmail.com"
SMTP_PASSWORD = "rhwv dptm mxpi lriz"



def read_log_entries(log_file_path):
    """ Continuously read log entries as they are written to the log file. """
    with open(log_file_path, "r") as file:
        # Move to the end of the file to read only new entries
        file.seek(0, 2)  
        while True:
            line = file.readline()
            if not line:
                time.sleep(0.1)  # Wait briefly for new content
                continue
            yield line

def check_for_ransomware_activity(log_entry):
    """ Check if the log entry suggests ransomware activity. """
    return ".enc" in log_entry or "high frequency" in log_entry

def alert_administrator():
    global last_alert_time
    
    current_time = datetime.datetime.now()
    
    # Check if enough time has passed since the last alert
    if last_alert_time is not None and (current_time - last_alert_time).total_seconds() < ALERT_COOLDOWN_PERIOD:
        print("Skipping alert due to cooldown period.")
        return
    
    print("ALERT: Potential ransomware activity detected.")
    email = '' # provide admin email 
    message = 'The ransomware process has been identified and stopped. starting the process of recovery.'
    msg = MIMEMultipart()
    msg['From'] = SMTP_USERNAME
    msg['To'] = email
    msg['Subject'] = "Ransomware detected "

    msg.attach(MIMEText(message, 'plain'))

    try:
        server = smtplib.SMTP(SMTP_SERVER, SMTP_PORT)
        server.starttls()
        server.login(SMTP_USERNAME, SMTP_PASSWORD)
        text = msg.as_string()
        server.sendmail(SMTP_USERNAME, email, text)
        server.quit()
        print("Alert sent to admin.")
        
        # Update the last alert time
        last_alert_time = current_time
    except Exception as e:
        print("Failed to send alert:", e)


def isolate_network_linux():
    """ Isolate the network on a Linux system to prevent ransomware spread. """
    print("ACTION: Isolating network to prevent further damage on Linux.")
    try:
        # Block all incoming traffic
        subprocess.run(['iptables', '-P', 'INPUT', 'DROP'], check=True)
        # Block all outgoing traffic
        subprocess.run(['iptables', '-P', 'OUTPUT', 'DROP'], check=True)
        print("Network successfully isolated.")
    except subprocess.CalledProcessError as e:
        print(f"Failed to update iptables rules: {e}")

def isolate_network_windows():
    """ Isolate the network on a Windows system to prevent ransomware spread. """
    print("ACTION: Isolating network to prevent further damage on Windows.")
    try:
        # Block all outgoing traffic
        subprocess.run(["powershell", "-Command", 
                        "New-NetFirewallRule -DisplayName 'Block Outgoing' -Direction Outbound -Action Block"], check=True)
        # Block all incoming traffic
        subprocess.run(["powershell", "-Command", 
                        "New-NetFirewallRule -DisplayName 'Block Incoming' -Direction Inbound -Action Block"], check=True)
        print("Network successfully isolated.")
    except subprocess.CalledProcessError as e:
        print(f"Failed to update firewall rules: {e}")


def terminate_suspicious_processes():
    print("ACTION: Scanning for and terminating suspicious processes.")
    suspicious_extensions = ['.enc', '.exe']  # Common ransomware file extensions
    for proc in psutil.process_iter(['pid', 'name', 'exe', 'cmdline']):
        try:
            # Check if the process is working with files with suspicious extensions
            if proc.info['cmdline']:  # Ensure cmdline is not None
                for cmd in proc.info['cmdline']:
                    if any(ext in cmd for ext in suspicious_extensions):
                        print(f"Terminating suspicious process {proc.info['name']} with PID {proc.info['pid']}")
                        proc.kill()
        except (psutil.NoSuchProcess, psutil.AccessDenied):
            continue




def restore_from_backup_windows(backup_path, target_path):
    
    print("ACTION: Restoring data from backups using robocopy.")
    try:
        subprocess.run(['robocopy', backup_path, target_path, '/MIR'], check=True)
        print(f"Data successfully restored from {backup_path} to {target_path}.")
    except subprocess.CalledProcessError as e:
        print(f"Failed to restore data: {e}")

def restore_from_backup_unix(backup_path, target_path):
    """ Restore data from backup using rsync on Unix-like systems. """
    print("ACTION: Restoring data from backups using rsync.")
    try:
        subprocess.run(['rsync', '-a', backup_path, target_path], check=True)
        print(f"Data successfully restored from {backup_path} to {target_path}.")
    except subprocess.CalledProcessError as e:
        print(f"Failed to restore data: {e}")

def main():
    print("Ransomware mitigation system initiated.")
    for entry in read_log_entries(LOG_FILE_PATH):
        
        if check_for_ransomware_activity(entry):
            alert_administrator()
            terminate_suspicious_processes()
            if platform.system() == 'Linux':
                # isolate_network_linux()
                restore_from_backup_unix('../critical-backup','../critical')
            elif platform.system() == 'Windows':
                isolate_network_windows()
                restore_from_backup_windows('../critical-backup','../critical')
            else:
                print("Unsupported operating system for network isolation.")


if __name__ == "__main__":
    main()
